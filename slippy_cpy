#!/usr/bin/env python3

# Implementation of subset of sed -E in Python
# usage: slippy [-i] [-n] [-f <script-file> | <sed-command>] [<files>...]
# Written by Sam Axford (z5359407)
# 8/8/2022

import sys
import re
import io
import os
import shutil
import argparse
import shlex



def is_valid_expression(str):
    return True

def parse_cmd_line(argv):
    in_place = False
    quiet = False
    script_file = False

    i = 1
    files = []
    commands = []
    command_still_expected = True
    while (i < len(argv)):
        # read in option flags
        option = re.match(r'-(.)', argv[i])
        if option:
            option = option.group(1)
            if option == 'i':
                in_place = True
            elif option == 'n':
                quiet = True
            elif option == 'f':
                script_file = True

                # check for script file immediately
                i += 1
                if not os.path.exists(argv[i]):
                    print(f"{sys.argv[0]}: error", file=sys.stderr)
                    sys.exit(1)
                else:
                    f = open(argv[i])
                    sed_cmd = f.read()
                    commands = parse_commands(sed_cmd)

                command_still_expected = False
            else:
                print(f"usage: {sys.argv[0]} [-i] [-n] [-f <script-file> | <sed-command>] [<files>...]", file=sys.stderr)
                sys.exit(1)

        else:
            # arg is not option -> check if valid sed expression or file
            if command_still_expected and not is_valid_expression(argv[i]): # redundant since correct input expected (aside from incorrect substitution regex) 
                print(f"{sys.argv[0]}: command line: invalid command", file=sys.stderr)
                sys.exit(1)

            if not command_still_expected and not os.path.exists(argv[i]):
                print(f"{sys.argv[0]}: error", file=sys.stderr)
                sys.exit(1)
            
            # save filename arguments (or command)
            if command_still_expected: 
                sed_cmd = argv[i]
                commands = parse_commands(sed_cmd)

                # should be only files from now
                command_still_expected = False 
            else:
                files.append(argv[i])   
        
        i += 1
            

    if (not files) and (command_still_expected or in_place):
        print(f"usage: {sys.argv[0]} [-i] [-n] [-f <script-file> | <sed-command>] [<files>...]", file=sys.stderr)
        sys.exit(1)
    
    options = {
                "i": in_place,
                "n": quiet,
                "f": script_file
    }
    return files, commands, options

def split_sed_command(sed_cmd):
    '''
    Splits the string sed_cmd at every instance of a ; or newline character, unless preceded by an odd number of backslashes,
    in which case, the immediately preceding backslash is removed.
    '''
    splits = ";\n"
    commands = []
    i = 0
    j = 0
    while i < len(sed_cmd):
        if sed_cmd[i] in splits and not re.search(r"^.*[^\\](\\\\)*\\$", sed_cmd[j:i]):
            cmd = sed_cmd[j:i]
            cmd = remove_backslash_before(splits, cmd)
            commands.append(sed_cmd[j:i])
            j = i + 1
        
        i += 1
    if sed_cmd[j:i] not in commands: commands.append(remove_backslash_before(splits, sed_cmd[j:i]))
    
    return commands

def remove_backslash_before(splits, cmd):
    i = 0
    while i < len(cmd):
        if cmd[i] in splits:
            cmd = cmd[:i-1] + cmd[i:]
        else:
            i += 1
    return cmd


def parse_commands(sed_cmd):
    '''
    Return list of Command subclasses representative of sed_cmd string
    '''

    # commands = []
    # for line in sed_cmd:
    #     while len(line) > 0:
    #         command, i = parse_command(line)
    #         commands.append(command)
    #         line = line[i:]

    commands = []
    while len(sed_cmd) > 0:
        command, i = parse_command(sed_cmd)
        commands.append(command)
        sed_cmd = sed_cmd[i:]

    return commands

def parse_command(cmd):
    '''
    Return Command subclass representative of cmd string.
    '''
    address1, address2, i = parse_addresses(cmd, 0)
    function, i = parse_function(cmd, i)
    
    command = Command.factory(address1, address2, function)

    i = command.parse_arguments(cmd, i) # <- this also always calls parse_tail(cmd, i)
    return command, i

def parse_addresses(cmd, i):
    '''
    example change in index i:
    ./slippy ' /a1/ ,/a2/   s/match/substitution/ g   # comment  (actual \n)   1,3p '
              ^          ^
    Returns:
        - starting_address, ending_address: ("$", "int", "regex", None)
        - i: int
    '''

    odd_backlashes = '.*[^\\](\\\\)*\\'

    # e.g. /a1/,/a2/ 
    double_regex = re.match('\s*/(\S*?[^(' + odd_backlashes + ')])/\s*,\s*/(\S*?[^(' + odd_backlashes + ')])/', cmd[i:])
    if double_regex:
        return double_regex.group(1), double_regex.group(2), i + double_regex.end(0)

    # e.g. /a1/
    regex = re.match('\s*/(\S*?[^(' + odd_backlashes + ')])/', cmd[i:])
    if regex:
        return regex.group(1), None, i + regex.end(0)
    
    # e.g. 1,2 or 479,$
    double_address = re.match('\s*([0-9]+|$)\s*,\s*([0-9]+|$)', cmd[i:])
    if double_address:
        a1 = double_address.group(1)
        a2 = double_address.group(2)
        for a in (a1, a2):
            if a == "$":
                # set address to be end
                a = -1

        return int(a1), int(a2), i + double_address.end(0)

    # e.g. 23 or $
    address = re.match('\s*([0-9]+|$)', cmd[i:])
    if address:
        a1 = address.group(1)
        if a1 == "$":
            a = -1
        return int(address.group(1)), None, i + address.end(0)

    return None, None, i

def parse_function(cmd, i):
    '''
    Gets function from command string cmd assuming index i is at position after addresses 
    (i.e. assumes i has been returned from parse_addresses(cmd, i) already).
    example change in index i:
    ./slippy ' /a1/ ,/a2/   s/match/substitution/ g   # comment  (actual \n)   1,3p '
                         ^   ^
    ./slippy ' 1234 ,/a2/   d    # comment, more comments'
                         ^       ^
    Returns:
        - function: str
        - i: int
    '''
    m = re.match('\s*(\S)\s*', cmd[i:])
    if m == None: return None, i
    return m.group(1), i + m.end(0)

def parse_sub_match(cmd, i, delim):
    '''
    example change in index i:
    ./slippy ' /a1/ ,/a2/   s/match/substitution/ g   # comment  (actual \n)   1,3p '
                              ^     ^
    '''
    match = None
    j = i
    while i < len(cmd):
        # break when we find the next delimeter (that has not been \escaped)
        if cmd[i] == delim and not re.search(r"^.*[^\\](\\\\)*\\$", cmd[j:i]):
            match = cmd[j:i]
            i += 1
            break
        
        i += 1
    return match, i

def parse_sub_substitution(cmd, i, delim):
    '''
    identical to parse_sub_match, just assumed later starting index
    example change in index i:
    ./slippy ' /a1/ ,/a2/   s/match/substitution/ g   # comment  (actual \n)   1,3p '
                                    ^            ^
    '''
    return parse_sub_match(cmd, i, delim)

def parse_tail(cmd, i):
    '''
    example change in index i:
    ./slippy ' /a1/ ,/a2/   s/match/substitution/ g   # comment  (actual \n)   1,3p '
                                                 ^                          ^
    ./slippy ' 1234 ,/a2/   d    # comment, more comments'
                                 ^                       ^
    '''
    modifier = None
    is_comment = False
    while i < len(cmd):
        if cmd[i] == "#":
            is_comment = True
        
        if cmd[i] == "g" and not is_comment:
            modifier = "g"

        if cmd[i] == "\n" or (cmd[i] == ";" and not is_comment):
            return modifier, i + 1
        
        i += 1

    return modifier, i











class Command:
    def __init__(self, address1, address2):
        self.address1 = address1
        self.address2 = address2
        if not address1 and not address2:
            self.is_active = True
        else:
            self.is_active = False
    
    def parse_arguments(self, cmd, i):
        # by default, parsing arguments will just move i to the start of the next command if it exists
        i = parse_tail(cmd, i)[1]
        return i

    @staticmethod
    def factory(address1, address2, function):
        classes = { ':': Command_label,
                    'a': Command_a,
                    'b': Command_b,
                    'c': Command_c,
                    'd': Command_d,
                    'i': Command_i,
                    'p': Command_p,
                    'q': Command_q,
                    's': Command_s,
                    't': Command_t,
                }

        if function == ':' and address1:
            print(f'{sys.argv[0]}: command line: invalid command', file=sys.stderr)
            sys.exit(1)
        if function == 'q' and address2:
            print(f'{sys.argv[0]}: command line: invalid command', file=sys.stderr)
            sys.exit(1)

        if function in classes:
            return classes[function](address1, address2)
        else:
            print(f'{sys.argv[0]}: command line: invalid command', file=sys.stderr)
            sys.exit(1)

    def apply(self, func, stream_line, i):
        if not stream_line: return stream_line

        if self.address1 and self.address2:
            # apply from address1 to address2 (inclusive)
            if not self.is_active and type(self.address1) == int:
                if i == self.address1:
                    self.is_active = True
            elif not self.is_active and type(self.address1 == str):
                if re.search(self.address1, stream_line):
                    self.is_active = True
            elif self.is_active and type(self.address2) == int:
                if i == self.address2:
                    self.is_active = False
                    stream_line = func(stream_line)
            elif self.is_active and type(self.address2 == str):
                if re.search(self.address2, stream_line):
                    self.is_active = False
                    stream_line = func(stream_line)
        elif self.address1:
            # apply only on address1
            if type(self.address1) == int:
                if i == self.address1:
                    stream_line = func(stream_line)
            elif type(self.address1 == str):
                if re.search(self.address1, stream_line):
                    stream_line = func(stream_line)
        
        # else no address specified -> apply on all

        if self.is_active: stream_line = func(stream_line)
        
        return stream_line



class Command_q(Command):
    # TODO: check if None or '' or both or something else optimal solution
    def apply(self, stream_line, slippy):
        if not stream_line: return stream_line

        if type(self.address1) == int:
            if slippy.i == self.address1:
                slippy.quit = True
        elif type(self.address1 == str):
            if re.search(self.address1, stream_line):
                slippy.quit = True
        
        return stream_line

class Command_p(Command):
    def apply(self, stream_line, i):
        def p(x):
            print(x, end='')
            return x
        return super().apply(p, stream_line, i)


    # def apply(self, stream_line, i):
    #     if not stream_line: return stream_line

    #     if self.address1 and self.address2:
    #         # apply from address1 to address2 (inclusive)
    #         if not self.is_active and type(self.address1) == int:
    #             if i == self.address1:
    #                 self.is_active = True
    #         elif not self.is_active and type(self.address1 == str):
    #             if re.search(self.address1, stream_line):
    #                 self.is_active = True
    #         elif self.is_active and type(self.address2) == int:
    #             if i == self.address2:
    #                 self.is_active = False
    #                 print(stream_line, end='')
    #         elif self.is_active and type(self.address2 == str):
    #             if re.search(self.address2, stream_line):
    #                 self.is_active = False
    #                 print(stream_line, end='')
    #     elif self.address1:
    #         # apply only on address1
    #         if type(self.address1) == int:
    #             if i == self.address1:
    #                 print(stream_line, end='')
    #         elif type(self.address1 == str):
    #             if re.search(self.address1, stream_line):
    #                 print(stream_line, end='')
        
    #     # else no address specified -> apply on all

    #     if self.is_active: print(stream_line, end='')
        
    #     return stream_line

class Command_d(Command):
    def apply(self, stream_line, i):
        return super().apply(lambda x: '', stream_line, i) # TODO: decide None or ''

    # def apply(self, stream_line, i):
    #     if not stream_line: return stream_line

    #     if self.address1 and self.address2:
    #         # apply from address1 to address2 (inclusive)
    #         if not self.is_active and type(self.address1) == int:
    #             if i == self.address1:
    #                 self.is_active = True
    #         elif not self.is_active and type(self.address1 == str):
    #             if re.search(self.address1, stream_line):
    #                 self.is_active = True
    #         elif self.is_active and type(self.address2) == int:
    #             if i == self.address2:
    #                 self.is_active = False
    #                 stream_line = None
    #         elif self.is_active and type(self.address2 == str):
    #             if re.search(self.address2, stream_line):
    #                 self.is_active = False
    #                 stream_line = None
    #     elif self.address1:
    #         # apply only on address1
    #         if type(self.address1) == int:
    #             if i == self.address1:
    #                 stream_line = None
    #         elif type(self.address1 == str):
    #             if re.search(self.address1, stream_line):
    #                 stream_line = None
        
    #     # else no address specified -> apply on all

    #     if self.is_active: stream_line = None # TODO: decide None or ''
        
    #     return stream_line

class Command_s(Command):
    def parse_arguments(self, cmd, i):
        '''
        example change in index i:
        ./slippy ' /a1/ ,/a2/   s/match/substitution/ g   # comment  (actual \n)   1,3p '
                                 ^                                              ^
        '''
        delim = cmd[i]
        match, i = parse_sub_match(cmd, i+1, delim)
        substitution, i = parse_sub_substitution(cmd, i, delim)

        modifier, i = parse_tail(cmd, i)

        sub_all = (modifier == 'g')
        self.args = {
                      "match": match,
                      "sub": substitution, 
                      "sub_all": sub_all
        }
        return i


    def apply(self, stream_line, i):
        def s(x):
            if self.args["sub_all"]:
                m = re.sub(self.args["match"], self.args["sub"], x)
            else:
                m = re.sub(self.args["match"], self.args["sub"], x, count=1)
            if m:
                return m
            else:
                return x
        return super().apply(s, stream_line, i)


class Command_label(Command):
    def apply(self, stream_line, i):
        pass

class Command_b(Command):
    def apply(self, stream_line, i):
        pass
    
class Command_t(Command):
    def apply(self, stream_line, i):
        pass

class Command_a(Command):
    def parse_arguments(cmd, i):
        # TODO: read all characters after and including first \S (non-whitespace) char until newline
        return
    # TODO: convert "\\n" on read to actual newline "\n" on print
    def apply(self, stream_line, i):
        pass

class Command_i(Command):
    def apply(self, stream_line, i):
        pass

class Command_c(Command):
    def apply(self, stream_line, i):
        pass


class Slippy():
    i = 1
    quit = False
    commands = []
    options = {
                "i": False,
                "n": False,
                "f": False
    }

    def __init__(self, commands, options):
        self.commands = commands
        self.options = options

    def should_read_ahead(self):
        # search for $ address
        for c in self.commands:
            if c.address1 == -1 or c.address2 == -1: return True
        return False
        
    def apply_commands(self, line, i):
        for c in self.commands:
            if isinstance(c, Command_q):
                line = c.apply(line, self)
            else:
                line = c.apply(line, i)
        return line
    
    def run(self, input_stream, out_name="out"):
        if options["i"]: 
            sys.stdout = open("tmp", 'w')

        if self.should_read_ahead():
            next = input_stream.readline()
            while not self.quit:
                line = next
                next = input_stream.readline()
                if not next:
                    # TODO: ensure this does not occur on empty line, only after final line
                    line = self.apply_commands(line, -1) # -1 = end address $
                    if not options["n"]: # not quiet
                        print(line, end='')
                    break
                line = self.apply_commands(line, self.i)

                # TODO: does this non-quiet print happen before or after applying commands?
                if not options["n"]: # not quiet
                    print(line, end='')
                
                self.i += 1
        else:
            while not self.quit:
                line = input_stream.readline()
                if not line:
                    # TODO: ensure this does not occur on empty line, only after final line
                    break
                line = self.apply_commands(line, self.i)

                if not options["n"]: # not quiet
                    print(line, end='')
                
                self.i += 1 
        
        if options["i"]: 
            sys.stdout.close()
            os.replace("tmp", out_name)
    




if __name__ == '__main__':
    files, commands, options = parse_cmd_line(sys.argv)

    if files:
        for filename in files:
            with open(filename, 'r') as f:
                slippy = Slippy(commands, options)
                slippy.run(f, out_name=filename)

    else:
        slippy = Slippy(commands, options)
        slippy.run(sys.stdin)
    





